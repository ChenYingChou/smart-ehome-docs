## 本地伺服器 ↔ 雲端伺服器

1. 標準 json 格式: `Cmd, Server, Module, Device, Function, Value, {Token}` <br> 基本同 "通訊轉接模組 ↔ 本地伺服器" 通訊協定，主要增加了一層 `Server ID` 或 `s_id`。

    範例: 設定 Server AMMA 會議室空調温度為 26 度。(由雲端伺服器轉自手機，發向 AMMA 本地伺服器)
    ```js
    {
        "cmd": 22,                      // 雲端伺服器 → 本地伺服器
        "AMMA": {                       // 本地伺服器: AMMA
            "AM210-1": {                // 模組ID
                "Conditioner": {        // 設備ID: 會議室空調
                    "Temperature": 26   // 功能ID: 温度 = 26°C
                }
            }
        }
    }
    ```

2. 本地伺服器第一次向雲端伺服器註冊:
    * REST API: `POST` `http://cloud-server:port/api`

    * MQTT: `mqtt://cloud-server:port`
        * 送出 `topic = "public"`
        * 接收 `topic = "reply"`

    * 送出本地伺服器所擁有的 "模組/設備/功能/類型/值域/UI 元件":
        ```js
        {
            "cmd": 97,                              // 本地伺服器 → 雲端伺服器
            "s_id": "**自定伺服器ID**",
            "name": "**自定伺服器名稱**",
            "modules": {                            // 模組物件
                "**模組ID**": {
                    "name": "**模組名稱**",
                    "devices": {                    // 設備物件
                        "**設備ID**": {
                            "name": "**設備名稱**",
                            "functions": {          // 功能物件
                                "**功能ID**": {
                                    "name": "**功能名稱**",
                                    "type": 1,              // 輸入(狀態):1, 輸出(控制):2, 輸出入:3
                                    "value": "__Value__",   // 1, 2, 3, 100/n, n1~n2
                                    "ui": "__UI__"          // UI 元件
                                },
                                // 第 2,3,... 功能
                            }
                        },
                        // 第 2,3,... 設備
                    },
                },
                // 第 2,3,... 模組
            },
            "key": "**16 個隨機字元轉十六進位字串, 共 32 HEX 字元**"
        }
        ```

        `modules` 物件的內容來自本地伺服器的組態，詳見 "通訊轉接模組 ↔ 本地伺服器" 說明。

    * 接收回應 JSON 格式:
        ```js
        {
            "cmd": 97,                          // 雲端伺服器 → 本地伺服器
            "s_id": "**自定伺服器ID**",         // 註冊時送出的**自定伺服器ID**
            "status": 0,                        // 0:成功, 非零:錯誤
            "payload": "**msg**"                // 加密資料 或 錯誤訊息
        }

        // 註冊成功後解密 payload 為 JSON 字串如下:
        {
            "id": "__伺服器唯一ID__",           // 若伺服器 ID 有衝突, 則為新伺服器 ID, 否則不變同原有送出的伺服器 ID
            "token": "__身份驗證令牌__"         // 送往 Server 要帶上此值
        }
        ```

        * 註冊失敗返回 payload 為錯誤訊息。
        * 註冊成功時返回 payload 要以 AES CTR 演算法用送出的 key 去解密，參考 [AES-JS](https://github.com/ricmoo/aes-js)。
        * 若自定伺服器 ID 與已註冊模組有衝突時，則會返回 `__伺服器唯一ID__`。以後通訊則必須使用這個指定的伺服器 ID。
        <br>

3. 通訊轉接模組向 Server 解除註冊:
    * REST API: `POST` `http://cloud-server:port/api`

    * MQTT: `mqtt://cloud-server:port`
        * 送出 `topic = "public"`
        * 接收 `topic = "reply"`

    * 送出本地伺服器解除註冊要求:
        ```js
        {
            "cmd": 96,                  // 本地伺服器 → 雲端伺服器
            "s_id": "**伺服器ID**",
            "token": "__身份驗證令牌__"
        }
        ```

    * 接收回應 JSON 格式:
        ```js
        {
            "cmd": 96,                  // 雲端伺服器 → 本地伺服器
            "s_id": "**伺服器ID**",
            "status": 0,                // 0:成功, 非零:錯誤
            "payload": "**msg**"
        }
        ```

        * 解除註冊失敗返回 payload 為錯誤訊息。
        * 即使不解除註冊，但只要本地伺服器離線超過一定期限，雲端伺服器也會自動解除註冊。亦可透過管理系統來解除註冊。
        * 解除註冊後要再重新註冊才可連線。
        <br>

4. 本地伺服器回應狀態給雲端伺服器: (當狀態改變或收到雲端伺服器要求回報現在狀態)
    * REST API: `POST` `http://cloud-server:port/api`

    * MQTT: `mqtt://cloud-server:port/public`

    * 回應狀態:
        ```js
        {
            "cmd": 11,                  // 本地伺服器 → 雲端伺服器
            "s_id": "**伺服器ID**",
            "modules": {
                "**模組ID**": {
                    "**設備ID**": {
                        "**功能ID**": "**最新狀態值**",
                        // 其餘功能的最新狀態值...
                    },
                    // 其餘設備的各功能狀態值...
                },
                // 其餘模組...
            },
            "token": "__身份驗證令牌__"
        }
        ```

5. 本地伺服器接收雲端伺服器命令:
    * MQTT: `mqtt://cloud-server:port/**伺服器ID**` <br> 因為是透過專用 Queue 通道，`**伺服器ID**` 一定是當初註冊給定的 `系統唯一ID`，故不需 `token` 不用驗證合法性。

    * 控制設備/功能為指定值:
        ```js
        {
            "cmd": 12,                  // 雲端伺服器 → 本地伺服器
            "**伺服器ID**": {
                "**模組ID**": {
                    "**設備ID**": {
                        "**功能ID1**": "**欲變更狀態值**",
                        "**功能ID2**": "**欲變更狀態值**",
                        // 其他功能...
                    },
                    // 其他設備...
                },
                // 其他模組...
            }
        }
        ```

    * 查詢設備/功能狀態:
        ```js
        {
            "cmd": 13,                  // 雲端伺服器 → 本地伺服器
            "**伺服器ID**": {
                "**模組ID**": {
                    "**設備ID**": [
                        // 查詢那些功能狀態
                        "**功能ID1**",
                        "**功能ID2**",
                        //...
                    ],
                    // 其他設備...
                },
                // 其他模組...
            }
        }
        ```

        * 若 `**伺服器ID**` 的值為空物件或空陣列，則表示要查全部的模組、設備及功能狀態值。
            ```js
            {
                "cmd": 13,                  // 雲端伺服器 → 本地伺服器
                "**伺服器ID**": {}
            }
            ```

        * 若 `**伺服器ID**` 的值為陣列，則表示要查陣列中指定模組的全部功能狀態值。
            ```js
            {
                "cmd": 13,                  // 雲端伺服器 → 本地伺服器
                "**伺服器ID**": ["**模組1**", "**模組2**", ...]
            }
            ```

    * 執行情境: (是否需要一次執行多個情境?)
        ```js
        {
            "cmd": 14,                  // 雲端伺服器 → 本地伺服器
            "**伺服器ID**": "**情境ID**"
        }
        ```
