## 本地伺服器資料集

1. 儲存和雲端伺服器通訊基本資料:

    ```js
    "server": {
        "s_id": "__自定伺服器ID__",
        "name": "**自定伺服器名稱**",
        "key": "**16 個隨機字元轉十六進位字串, 共 32 HEX 字元**",
        "token": "__身份驗證令牌__"
    }
    ```

1. 通訊模組註冊資料:

    ```js
    "modules": {
        "__模組ID__": {
            "active": true,                     // 模組啟用中, 或太久失聯被停用
            "timestamp": 0                      // 最後回應時間
            "name": "**模組名稱**",
            "key": "**16 個隨機字元轉十六進位字串, 共 32 HEX 字元**",
            "token": "__身份驗證令牌__",
            "devices": {                        // 設備物件
                "**設備ID**": {
                    "name": "**設備名稱**",
                    "functions": {              // 功能物件
                        "**功能ID**": {
                            "name": "**功能名稱**",
                            "type": 1,              // 輸入(讀取狀態):1, 輸出(控制):2, 輸出入:3
                            "value": "__Value__",   // 1, 2, 3, 100/n, n1~n2
                            "ui": "__UI__",         // UI 元件
                            "attention": {          // 可關注才有 (一定要有可讀取狀態, type & 1 == 1)
                                "message": "**通知訊息**",
                                "icon": "**icon檔**",
                                "sound": "**音效檔**"
                            },
                            "keep_last": 1,         // 記錄最近多少秒的狀態值: 1~3600 (指系統內部，非資料庫儲存)
                            "status": [],           // 內部記錄: 最後 keep_last 秒的狀態值
                            "timestamp": 0          // milliseconds since 01 January, 1970 UTC (54 bits)
                        },
                        // 其他功能...
                    }
                },
                // 其他設備...
            }
        },
        // 其他模組...
    }
    ```

    * `status[]` 內的值以 4 bytes 表示各時間點 (最近 3600 秒) 的值，0x80000000 表示該秒無值。若以 js 編寫則為 null 值。
    <br>

1. 以下 `actions`、`scenes`、`states` 可用下列 ABNF 語法表示之:

    ```bnf
    action-list = "[" *1concurrent *( action   / action-list ) "]"
    scene-list  = "[" *1concurrent *( scene-id / scene-list  ) "]"
    state-list  = "[" *1concurrent *( state-id / state-list  ) "]"
    concurrent  = "C"

    ; 註: 陣列中的第一個值若為 "C" 表示併行 (Concurrent) 執行此陣列其他行為，即算結束本任務。
    ```

1. 情境:

    ```js
    <action> {
        "id": "**模組ID+設備ID+功能ID**",
        "delay0": 0,                // 執行前延遲時間，精確度 0.1 秒
        "value": "**值**"
    }

    "scenes": {
        "**情境ID**": {
            "name": "**情境名稱**",
            "active": true,         // 是否正在執行中
            "delay0": 0,            // 執行前延遲時間，精確度 0.1 秒
            "mode": 1,              // 重疊執行時 (同一情境之前的還在執行中) -- 0:取消都不執行, 1:以新的取代舊的, 2:舊的繼續/新的取消, 3:舊的繼續/新的開始執行
            "actions": [            // <action list>
                <action>,
                // 其他 action ...
            ]
        },
        // 其他情境...
    }
    ```

    * `情境ID.mode` 同一情境重疊執行時，以 bit1 (舊情境)、 bit0 (新情境) 表示是否執行之。當 bit1 為零時如果有舊的情境的話停止執行舊情境，bit0 為 1 時執行新的情境。
    * 情境控制時的 `value` 可為 0 或 非零:
        * 0 表示若同一情境已在執行中則中止之。
        * 非零則為觸發執行，若無同一情境在執行則直接執行，否則需視 `情境ID.mode` 決定之。
    <br>

1. 智慧控制:

    ```js
    <node> {        // 運算後返回值 -- 0:失敗, 1:成功但持續時間未滿足, 2:成功且已滿足持續時間
        "op": "",                   // '+','-','*','/',('<','>','='),'&','|','^','&&','||','!'
                                    // 函數 mean,max,min,count: left=變數, right=最近多少筆 (秒)
        "left": <node>,             // 變數 $1~$n, 或左 Node
        "right": <node>,            // 變數 $1~$n, 或右 Node
        "duration": 0,              // 要求持續時間 (精確度 0.1 秒)
        "elapsed": 0                // 已持續時間 (精確度 0.1 秒)
    }

    "wisdoms": {    // 智慧控制物件
        "**智慧控制ID**": {
            "active": true,                     // 啟用或停用
            "name": "**智慧控制名稱**",
            "states": [ "**狀態機ID**", ... ]   // 循環執行 <state list>
        },
        // 其他智慧控制...
    }

    "states": {     // 狀態機物件
        "**狀態機ID**": {
            "name": "**狀態名稱**",
            "condition": {          // 要滿足的條件
                "vars": [ "**模組ID+設備ID+功能ID**", ... ],
                "expr": "**條件運算式**"     // 以 `$1~$n` 表示對應 vars[] 的 `模組ID+設備ID+功能ID` 狀態值
            },
            "run": {                // 滿足條件後同時執行 actions、scenes
                "actions": [                    // <action list>
                    <action>,
                    // 其他 action ...
                ],
                "scenes": [ "**情境ID**", ... ] // <scene list>
            },
            "delay": 0              // 延遲時間之後才結束本狀態機，精確度 0.1 秒
        },
        // 其他狀態機...
    }
    ```

    * 智慧控制的 `active` 設為 `false` 表示停用，可由排程指定的時間或 Apps 用戶觸發啟用或停用之。
    * 智慧控制在啟用中會依序或併行執行 `states[]` 的狀態機，當執行到尾時會循環繼續執行。
    * 狀態機 `條件運算式` 中可含 `:duration` 表示該運算式需持續滿足多少秒 (精確度 0.1 秒)。
    * 狀態機 `run` 中的 `actions`、`scenes` 同時存在的話，會同時執行。
    * 狀態機 `delay` 是指 `run` 開始執行起計算的延遲時間，並非 `run` 執行完後的延遲時間。
    <br>

1. 排程:

    ```js
    "schedules" : {
        "**排程ID**": {
            "active": true,                 // 是否啟用
            "name": "**排程名稱**",
            "timer": {
                "date_start": "",           // YYYY-MM-DD: 起始日期
                "date_end": "",             // YYYY-MM-DD: 結束日期
                "except_holidays": false,   // 是否排除例假日，通常配合工作日 (週1~週5) 使用
                "weeks": [],                // 0~6: 週日~週六
                "months": [],               // 1~12 月
                "days": [],                 // 1~31 日
                "hours": [],                // 0~23 時
                "minutes": []               // 0~59 分
            },
            "run": {                // 到達時間時同時執行 actions、scenes
                "actions": [                // 依順序執行
                    <action>,
                    // 其他 action ...
                ],
                "scenes": [ "**情境ID**", ... ],
                "wisdoms_on": [ "**智慧控制ID**", ... ],    // 啟動智慧控制，開始執行 states[] 任務
                "widdoms_off": [ "**智慧控制ID**", ... ]    // 關閉智慧控制，並將執行中相關的任務移除
            }
        },
        // 其他排程...
    }
    ```

    *  系統排程每分鐘整檢查一次。
    * `timer` 中的 (`date_start`, `date_end`, `days`, `weeks`, `hours`) 可以省略或以空值表示之。
    * `except_holidays` 需建立例假日清單 (YYYY-MM-DD)，通常配合工作日 (週1~週5) 使用。
    * `timer.minutes` 至少要指定一個值。
    * `run` 至少要指定 `actions`、`scenes`、`wisdoms_on`、`wisdoms_off` 其中一項。
    <br>

1. 關注: 只接收控制 (推播 iOS, Android 訊息)，不需狀態回報

    ```js
    "attentions": {
        "**模組ID+設備ID+功能ID**": {
            "name": "**功能名稱**",
            "message": "入侵: 1 樓大門",
            "sound": "**音效檔**",
            "icon": "**圖示檔**"
        },
        "**模組ID+設備ID+功能ID**": {
            "name": "**功能名稱**",
            "message": "煙霧警報: 2 樓厨房",
            "sound": "**音效ID**",
            "icon": "**圖示ID**"
        },
        // 其他關注...
    }

    "push_vendors": {   // 那些人透過什麼方式關注
        // 行動裝置訊息推播: 日期時間、訊息、音效ID、圖示ID
        "Apple": { "**endpoint**",... },        // iOS
        "Google": { "**endpoint**",... },       // Android
        // Android: 其他服務商 (中國大陸地區用)...

        // 社群網站: 日期、時間、訊息
        "Facebook": { "account,token",... },    // Facebook: 不確定需那些資訊?
        "LINE": { "account,token",... },        // LINE: 不確定需那些資訊?

        // 簡訊及電子郵箱: : 日期、時間、訊息
        "SMS": { "8860910123456",... },         // 簡訊: 是否要含國際碼?
        "Email": { "email@example.com",... }
    }
    ```

    * 由通訊模組註冊資料可關注選項自動產生。
    * 是否可由用戶自行選擇要關注那些項目 `模組ID+設備ID+功能ID` ?
    * 本模組收到控制命令中的 `功能ID` = `模組ID+設備ID+功能ID` 後，根據 `push_vendors` 逐一推播訊息。
    * 是否有方法得知那些裝置 (endpoint) 已失效，自動移除之。
    * 要有 API 使 Apps 能獲取到最近 (三個月) 的推播訊息。
    * 如何得知用戶使用那種方式關注? 經由 Web 網頁掃描不同條碼 (手機、各社群網站、SMS、Email)?

    <br>

1. 系統情境、智慧控制、排程、關注通訊模組:

    ```js
    {
        "m_id": "$SYS",
        "name": "**系統服務**",
        "key": "**16 個隨機字元轉十六進位字串, 共 32 HEX 字元**",
        "token": "__身份驗證令牌__"
    }
    ```

    * 關注控制: 只有觸發控制 (pulse)，進行訊息推播。
    * 情境、智慧控制及排程: 控制啟用/停用，回報現有狀態。
    * 直接使用 `scenes`、`wisdoms`、`schedules`、`attentions` 物件，因此要和系統管理程式合併在一起。
    * 控制命令中 `設備ID` = (`SCENES`,`WISDOMS`,`SCHEDULES`,`ATTENTIONS`) 其中之一。`功能ID` 為其下的 `情境/智慧控制/排程ID`，對關注而言則為 `模組ID+設備ID+功能ID`。
    * 需有增刪改某項情境、智慧控制、排程、關注等 API，需注意刪除時的關聯問題 (排程可包含智慧控制、情境，智慧控制可包含情境)。
    * `模組ID+設備ID+功能ID` 組態中的 type bit 5 (智慧控制/排程) 為 on 時，對應的組態 `keep_last = 系統預設值 3600` 及 `status[3600]` 記錄最近一小時的每秒值。
    * 提供 API 倒數計時執行 `action` (包含一般 `模組+設備+功能` 控制，亦包含了情境、智慧控制、排程、關注的啟用/停用)。
    * 提供 API 觀察目前任務列中的狀況，那些任務正在執行或延遲等待中。
    <br>

1. 天氣查詢通訊模組: 是否統一由雲端伺服器來查詢各地天氣?
